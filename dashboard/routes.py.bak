# dashboard/routes.py (Final Sürümü)
from flask import flash, redirect, render_template, request, jsonify, url_for, Blueprint, session
from models import db, Note, Task, User, Tag, Badge
import bleach # GÜVENLİK İÇİN EKLENDİ
from flask_login import login_required, current_user
from datetime import datetime, timedelta
import random # YENİ: Rastgele mesaj seçimi için

# Blueprint tanımlaması
dashboard_bp = Blueprint('dashboard', __name__, template_folder="../templates")

# Anasayfa
@dashboard_bp.route('/')
@login_required
def home():
    # Oturum kontrolünü kaldırıp her zaman gösterilecek şekilde ayarlandı.
    show_modal = True
    messages = [
        "Bugün harika işler başaracaksın!",
        "Her büyük başarı, küçük bir adımla başlar.",
        "Kendine inan, gerisi gelecek.",
        "Bugünün hedeflerine odaklan, yarın daha güçlü olacaksın.",
        "Potansiyelinin farkına var ve onu serbest bırak!"
    ]
    motivational_message = random.choice(messages)

    return render_template('base.html', show_welcome_modal=show_modal, motivational_message=motivational_message)

# --- YENİ: ROZET SİSTEMİ ---

BADGE_CRITERIA = {
    'notes_created_1': {'name': 'Not Defteri', 'description': 'İlk notunu oluşturdun!', 'icon': 'bi-journal-plus'},
    'notes_created_5': {'name': 'Not Tutkun', 'description': '5 adet not oluşturdun!', 'icon': 'bi-journals'},
    'notes_created_25': {'name': 'Koleksiyoner', 'description': 'Tam 25 not oluşturdun! Harika bir arşiv.', 'icon': 'bi-archive-fill'},
    'notes_created_10': {'name': 'Yazar Ruhu', 'description': '10 not oluşturdun!', 'icon': 'bi-pen-fill'},
    'notes_created_50': {'name': 'Kütüphane Kurucusu', 'description': '50 nota ulaştın!', 'icon': 'bi-book-half'},
    'consecutive_notes_3': {'name': 'Düşünce Fırtınası', 'description': '5 dakika içinde 3 not ekledin!', 'icon': 'bi-hurricane'},
    'note_editor_10': {'name': 'Düzen Delisi', 'description': '10 farklı notunu düzenledin.', 'icon': 'bi-eraser-fill'},
    'eraser_master_5': {'name': 'Silgi Ustası', 'description': '5 notu sildin, sadeleşmek de bir başarı!', 'icon': 'bi-scissors'},
    'tasks_completed_1': {'name': 'Görev Avcısı', 'description': 'İlk görevini tamamladın!', 'icon': 'bi-check-circle'},
    'tasks_completed_10': {'name': 'Verimlilik Ustası', 'description': '10 adet görev tamamladın!', 'icon': 'bi-check-all'},
    'tasks_completed_25': {'name': 'Verimlilik Maratonu', 'description': '25 görev tamamladın! Durdurulamazsın.', 'icon': 'bi-trophy-fill'},
    'tasks_created_50': {'name': 'Görev Mimarı', 'description': '50 görev oluşturdun.', 'icon': 'bi-building-gear'},
    'tasks_created_100': {'name': 'Görev Koleksiyoneri', 'description': '100 görevle sınırları zorluyorsun!', 'icon': 'bi-collection-fill'},
    'starred_item_1': {'name': 'Önemli Olan', 'description': 'İlk öğeni yıldızladın!', 'icon': 'bi-star-fill'},
    'night_owl_1': {'name': 'Gece Kuşu', 'description': 'Saat 22:00\'den sonra bir görev tamamladın!', 'icon': 'bi-moon-stars-fill'},
    'night_watch_1': {'name': 'Gece Bekçisi', 'description': 'Saat 02:00\'den sonra görev tamamladın!', 'icon': 'bi-stopwatch-fill'},
    'tag_master_1': {'name': 'Etiket Ustası', 'description': '5 farklı etiket oluşturdun!', 'icon': 'bi-tags-fill'},
    'tag_collector_10': {'name': 'Etiket Koleksiyoneri', 'description': '10 farklı etiket oluşturdun!', 'icon': 'bi-bookmark-star-fill'},
    'first_tag_created': {'name': 'İlk Etiket', 'description': 'İlk etiketini oluşturdun!', 'icon': 'bi-tag'},
    'time_traveler_1': {'name': 'Zaman Yolcusu', 'description': 'İlk kez bir göreve bitiş tarihi ekledin!', 'icon': 'bi-calendar-check'},
    'early_planner_1': {'name': 'Erken Planlayıcı', 'description': 'Görevini en az 3 gün önceden ekledin!', 'icon': 'bi-calendar2-event-fill'},
    'punctual_champion_1': {'name': 'Dakik Şampiyon', 'description': 'Bir görevi tam bitiş saatinde tamamladın!', 'icon': 'bi-bullseye'},
    'first_note_edited': {'name': 'Not Düzenleyici', 'description': 'İlk notunu başarıyla düzenledin!', 'icon': 'bi-pencil-square'},
    'early_bird_1': {'name': 'Erken Kalkan', 'description': 'Sabah 8\'den önce bir görev tamamladın!', 'icon': 'bi-sunrise'},
    'weekend_warrior_1': {'name': 'Hafta Sonu Savaşçısı', 'description': 'Hafta sonu bir görev tamamladın!', 'icon': 'bi-calendar-week'},
    'mission_completed_5': {'name': 'Misyon Tamamlandı', 'description': '5 farklı rozet kazandın!', 'icon': 'bi-award'},
    'badge_hunter_10': {'name': 'Rozet Avcısı', 'description': '10 farklı rozet topladın!', 'icon': 'bi-gem'},
    'legend_mode_25': {'name': 'Efsane Modu', 'description': '25 rozetle efsaneler arasına girdin!', 'icon': 'bi-shield-shaded'},
}

def check_and_award_badges(user):
    """Kullanıcının rozet kriterlerini kontrol eder ve yeni rozetler verir."""
    newly_awarded_badges = []
    user_badge_keys = {badge.criteria_key for badge in user.badges}

    # Kriter 1: Oluşturulan not sayısı
    note_count = db.session.scalar(db.select(db.func.count(Note.id)).filter_by(user_id=user.id))
    if note_count >= 1 and 'notes_created_1' not in user_badge_keys:
        newly_awarded_badges.append('notes_created_1')
    if note_count >= 5 and 'notes_created_5' not in user_badge_keys:
        newly_awarded_badges.append('notes_created_5')
    if note_count >= 10 and 'notes_created_10' not in user_badge_keys:
        newly_awarded_badges.append('notes_created_10')
    if note_count >= 25 and 'notes_created_25' not in user_badge_keys:
        newly_awarded_badges.append('notes_created_25')
    if note_count >= 50 and 'notes_created_50' not in user_badge_keys:
        newly_awarded_badges.append('notes_created_50')

    # Kriter 2: Tamamlanan görev sayısı
    completed_task_count = db.session.scalar(db.select(db.func.count(Task.id)).filter_by(user_id=user.id, completed=True))
    if completed_task_count >= 1 and 'tasks_completed_1' not in user_badge_keys:
        newly_awarded_badges.append('tasks_completed_1')
    if completed_task_count >= 10 and 'tasks_completed_10' not in user_badge_keys:
        newly_awarded_badges.append('tasks_completed_10')
    if completed_task_count >= 25 and 'tasks_completed_25' not in user_badge_keys:
        newly_awarded_badges.append('tasks_completed_25')

    # Kriter: Oluşturulan görev sayısı
    total_task_count = db.session.scalar(db.select(db.func.count(Task.id)).filter_by(user_id=user.id))
    if total_task_count >= 50 and 'tasks_created_50' not in user_badge_keys:
        newly_awarded_badges.append('tasks_created_50')
    if total_task_count >= 100 and 'tasks_created_100' not in user_badge_keys:
        newly_awarded_badges.append('tasks_created_100')

    # Kriter 3: Yıldızlı öğe sayısı
    starred_notes = db.session.scalar(db.select(db.func.count(Note.id)).filter_by(user_id=user.id, starred=True))
    starred_tasks = db.session.scalar(db.select(db.func.count(Task.id)).filter_by(user_id=user.id, starred=True))
    if (starred_notes + starred_tasks) >= 1 and 'starred_item_1' not in user_badge_keys:
        newly_awarded_badges.append('starred_item_1')

    # Kriter 4: İlk Etiket
    tag_count = db.session.scalar(db.select(db.func.count(Tag.id)).filter_by(user_id=user.id))
    if tag_count >= 1 and 'first_tag_created' not in user_badge_keys:
        newly_awarded_badges.append('first_tag_created')

    # Kriter 5: Not Düzenleyici (İlk notunu düzenlediğinde)
    edited_notes_count = db.session.scalar(db.select(db.func.count(Note.id)).filter(
        Note.user_id == user.id,
        Note.last_updated != Note.created_at
    ))
    if edited_notes_count >= 1 and 'first_note_edited' not in user_badge_keys:
        newly_awarded_badges.append('first_note_edited')
    if edited_notes_count >= 10 and 'note_editor_10' not in user_badge_keys:
        newly_awarded_badges.append('note_editor_10')

    # Kriter 6: Etiket Sayısı
    tag_count = db.session.scalar(db.select(db.func.count(Tag.id)).filter_by(user_id=user.id))
    if tag_count >= 5 and 'tag_master_1' not in user_badge_keys:
        newly_awarded_badges.append('tag_master_1')
    if tag_count >= 10 and 'tag_collector_10' not in user_badge_keys:
        newly_awarded_badges.append('tag_collector_10')

    # Kriter 7: Zaman Yolcusu (Bitiş tarihi olan görev)
    has_due_date_task = db.session.scalar(db.select(Task.id).filter(Task.user_id == user.id, Task.due_date.isnot(None)).limit(1))
    if has_due_date_task and 'time_traveler_1' not in user_badge_keys:
        newly_awarded_badges.append('time_traveler_1')

    # Kriter 8: Silgi Ustası
    # NoneType hatasını önlemek için 'or 0' ekleniyor
    if (user.notes_deleted_count or 0) >= 5 and 'eraser_master_5' not in user_badge_keys:
        newly_awarded_badges.append('eraser_master_5')

    # --- META ROZETLER (Diğer rozetlere göre) ---
    # Bu kontrol, diğer tüm rozetler eklendikten sonra yapılmalı.
    # `newly_awarded_badges` listesi, bu döngüde kazanılanları içerir.
    # `user_badge_keys` ise önceden kazanılmış olanları.
    total_badges_count = len(user_badge_keys) + len(newly_awarded_badges)
    
    if total_badges_count >= 5 and 'mission_completed_5' not in user_badge_keys and 'mission_completed_5' not in newly_awarded_badges:
        newly_awarded_badges.append('mission_completed_5')
    
    if total_badges_count >= 10 and 'badge_hunter_10' not in user_badge_keys and 'badge_hunter_10' not in newly_awarded_badges:
        newly_awarded_badges.append('badge_hunter_10')

    if total_badges_count >= 25 and 'legend_mode_25' not in user_badge_keys and 'legend_mode_25' not in newly_awarded_badges:
        newly_awarded_badges.append('legend_mode_25')

    # Yeni kazanılan rozetleri veritabanına ekle
    for key in newly_awarded_badges:
        badge = Badge.query.filter_by(criteria_key=key).first()
        if badge:
            user.badges.append(badge)
    
    db.session.commit()
    return [BADGE_CRITERIA[key] for key in newly_awarded_badges]

# --- YARDIMCI FONKSİYON ---
def process_tags(tag_string, user_id):
    """Virgülle ayrılmış etiket string'ini işler, Tag nesneleri listesi döndürür."""
    if not tag_string:
        return []
    
    tag_names = [name.strip().lower() for name in tag_string.split(',') if name.strip()]
    tags = []
    for name in tag_names:
        # Mevcut etiketi bul veya oluştur
        tag = Tag.query.filter_by(name=name, user_id=user_id).first()
        if not tag:
            tag = Tag(name=name, user_id=user_id)
            db.session.add(tag)
        tags.append(tag)
    db.session.commit() # Yeni etiketleri kaydet
    return tags

# --- NOTLAR (AJAX API) ---

@dashboard_bp.route("/add_note", methods=["POST"])
@login_required
def add_note_post():
    title = request.form.get("title")
    tag_string = request.form.get("tags", "")
    raw_content = request.form.get("content")
    if not title or not raw_content:
        return jsonify({"success": False, "message": "Başlık ve içerik boş bırakılamaz."}), 400
    
    # GÜVENLİK: HTML içeriğini temizle
    allowed_tags = [] # Zengin metin editörü kaldırıldığı için HTML'e izin verme
    content = bleach.clean(raw_content, tags=allowed_tags)

    new_note = Note(title=title, content=content, user_id=current_user.id)
    db.session.add(new_note)
    db.session.commit()
    new_note.tags = process_tags(tag_string, current_user.id)
    db.session.commit()

    # Rozet kontrolü
    new_badges = check_and_award_badges(current_user) # Genel kontroller

    # YENİ: Düşünce Fırtınası rozeti için özel kontrol
    if 'consecutive_notes_3' not in {b.criteria_key for b in current_user.badges}:
        last_three_notes = Note.query.filter_by(user_id=current_user.id).order_by(Note.created_at.desc()).limit(3).all()
        if len(last_three_notes) == 3:
            time_diff = last_three_notes[0].created_at - last_three_notes[2].created_at
            if time_diff <= timedelta(minutes=5):
                badge = Badge.query.filter_by(criteria_key='consecutive_notes_3').first()
                if badge and badge not in current_user.badges:
                    current_user.badges.append(badge)
                    db.session.commit()
                    new_badges.append(BADGE_CRITERIA['consecutive_notes_3'])

    return jsonify({"success": True, "message": "Not başarıyla kaydedildi.", "new_badges": new_badges})

@dashboard_bp.route("/get_notes")
@login_required
def get_notes():
    notes = Note.query.filter_by(user_id=current_user.id).order_by(Note.last_updated.desc()).all()
    notes_list = [
        {
            "id": n.id,
            "title": n.title,
            "content": n.content,
            "starred": n.starred,
            "last_updated": n.last_updated.strftime('%Y-%m-%d %H:%M'),
            "tags": [tag.name for tag in n.tags]
        }
        for n in notes
    ]
    return jsonify(notes_list)

@dashboard_bp.route("/delete_note/<int:note_id>", methods=["DELETE"])
@login_required
def delete_note(note_id):
    note = Note.query.get_or_404(note_id)
    if note.user_id != current_user.id:
        return jsonify({"success": False, "message": "Yetkisiz işlem"}), 403
    
    # YENİ: Silme sayacını artır
    # NoneType hatasını önlemek için kontrol ekleniyor
    current_user.notes_deleted_count = (current_user.notes_deleted_count or 0) + 1

    db.session.delete(note)
    db.session.commit()

    # Rozet kontrolü (Silgi Ustası için)
    check_and_award_badges(current_user)
    return jsonify({"success": True, "message": f"Not '{note.title}' silindi."})

@dashboard_bp.route("/update_note/<int:note_id>", methods=["POST"])
@login_required
def update_note_post(note_id):
    note = Note.query.get_or_404(note_id)
    if note.user_id != current_user.id:
        return jsonify({"success": False, "message": "Yetkisiz işlem"}), 403
    
    note.title = request.form.get("title")
    tag_string = request.form.get("tags", "")
    raw_content = request.form.get("content")
    # GÜVENLİK: HTML içeriğini temizle
    allowed_tags = []
    note.content = bleach.clean(raw_content, tags=allowed_tags)
    note.tags = process_tags(tag_string, current_user.id)

    db.session.commit()

    # Rozet kontrolü (Not Düzenleyici ve Düzen Delisi için)
    new_badges = check_and_award_badges(current_user)

    return jsonify({"success": True, "message": "Not başarıyla güncellendi!", "new_badges": new_badges})

@dashboard_bp.route("/toggle_star/<int:note_id>", methods=["POST"])
@login_required
def toggle_star(note_id):
    note = Note.query.get_or_404(note_id)
    if note.user_id != current_user.id:
        return jsonify({"success": False, "message": "Yetkisiz işlem"}), 403
    note.starred = not note.starred
    db.session.commit()
    message = f"'{note.title}' {'yıldızlandı. ⭐' if note.starred else 'yıldızlardan kaldırıldı. ☆'}"
    
    # Rozet kontrolü
    new_badges = check_and_award_badges(current_user)
    return jsonify({"success": True, "starred": note.starred, "message": message, "new_badges": new_badges})

@dashboard_bp.route("/delete_all_notes", methods=["POST"])
@login_required
def delete_all_notes():
    # Sadece mevcut kullanıcıya ait tüm notları sil
    Note.query.filter_by(user_id=current_user.id).delete()
    db.session.commit()
    return jsonify({"success": True, "message": "Tüm notlar başarıyla silindi."})

# --- GÖREVLER (AJAX API) ---

@dashboard_bp.route("/all_tasks_data")
@login_required
def all_tasks_data():
    # SIRALAMAYI GÜNCELLE: Önce tamamlanma durumu, sonra özel sıra, sonra oluşturulma tarihi
    tasks = Task.query.filter_by(user_id=current_user.id).order_by(Task.completed, Task.order, Task.id.desc()).all()
    tasks_list = [
        {
            "id": t.id,
            "title": t.title,
            "content": t.content,
            "due_date": t.due_date.strftime("%Y-%m-%dT%H:%M") if t.due_date else "",
            "starred": t.starred,
            "completed": t.completed,
            "order": t.order,
            "tags": [tag.name for tag in t.tags]
        }
        for t in tasks
    ]
    return jsonify(tasks_list)

@dashboard_bp.route("/add_task", methods=["POST"])
@login_required
def add_task_post():
    title = request.form.get("title")
    content = request.form.get("content")
    tag_string = request.form.get("tags", "")
    due_date_str = request.form.get("due_date")
    starred = request.form.get("starred") == 'on' # YENİ: Yıldız durumu formdan alınıyor

    if not title:
        return jsonify({"success": False, "message": "Başlık boş bırakılamaz!"}), 400

    due_date = None
    if due_date_str:
        try:
            due_date = datetime.strptime(due_date_str, "%Y-%m-%dT%H:%M")
        except ValueError:
            return jsonify({"success": False, "message": "Geçersiz bitiş tarihi formatı."}), 400

    # Yeni göreve en yüksek sıra numarasını ver
    last_task = Task.query.filter_by(user_id=current_user.id).order_by(Task.order.desc().nulls_last()).first()
    new_order = (last_task.order + 1) if last_task and last_task.order is not None else 0


    new_task = Task(title=title, content=content, due_date=due_date, user_id=current_user.id, order=new_order, starred=starred)
    db.session.add(new_task)
    db.session.commit()
    new_task.tags = process_tags(tag_string, current_user.id)
    db.session.commit()
    
    # Rozet kontrolü
    new_badges = check_and_award_badges(current_user)

    # YENİ: Erken Planlayıcı rozeti için özel kontrol
    if due_date and (due_date - datetime.now()) >= timedelta(days=3) and 'early_planner_1' not in {b.criteria_key for b in current_user.badges}:
        badge = Badge.query.filter_by(criteria_key='early_planner_1').first()
        if badge and badge not in current_user.badges:
            current_user.badges.append(badge)
            db.session.commit()
            new_badges.append(BADGE_CRITERIA['early_planner_1'])

    return jsonify({"success": True, "message": "Yeni görev başarıyla eklendi.", "new_badges": new_badges})

@dashboard_bp.route("/delete_task/<int:task_id>", methods=["DELETE"])
@login_required
def delete_task(task_id):
    task = Task.query.get_or_404(task_id)
    if task.user_id != current_user.id:
        return jsonify({"success": False, "message": "Yetkisiz işlem"}), 403
    db.session.delete(task)
    db.session.commit()
    return jsonify({"success": True, "message": f"Görev '{task.title}' silindi."})

# Tüm görevleri silme rotası
@dashboard_bp.route("/delete_all_tasks", methods=["POST"])
@login_required
def delete_all_tasks():
    Task.query.filter_by(user_id=current_user.id).delete()
    db.session.commit()
    return jsonify({"success": True, "message": "Tüm görevler başarıyla silindi."})


@dashboard_bp.route("/update_task/<int:task_id>", methods=["POST"])
@login_required
def update_task_post(task_id):
    task = Task.query.get_or_404(task_id)
    if task.user_id != current_user.id:
        return jsonify({"success": False, "message": "Yetkisiz işlem"}), 403
    
    title = request.form.get("title")
    content = request.form.get("content")
    tag_string = request.form.get("tags", "")
    due_date_str = request.form.get("due_date")
    
    if not title:
        return jsonify({"success": False, "message": "Başlık boş bırakılamaz!"}), 400
    
    task.title = title
    task.content = content
    task.tags = process_tags(tag_string, current_user.id)

    if due_date_str:
        try:
            task.due_date = datetime.strptime(due_date_str, "%Y-%m-%dT%H:%M")
        except ValueError:
            return jsonify({"success": False, "message": "Geçersiz bitiş tarihi formatı."}), 400
    else:
        task.due_date = None

    # Rozet kontrolü (özellikle "Zaman Yolcusu", "Etiket Ustası" ve "Not Düzenleyici" için)
    # Not: Bu, `check_and_award_badges` fonksiyonunu çağırmak için iyi bir yerdir.
    # Çünkü hem yeni etiketler eklenmiş olabilir hem de ilk kez bitiş tarihi girilmiş olabilir.
    new_badges = check_and_award_badges(current_user)

    db.session.commit()
    return jsonify({"success": True, "message": "Görev başarıyla güncellendi!", "new_badges": new_badges})

@dashboard_bp.route("/toggle_complete/<int:task_id>", methods=["POST"])
@login_required
def toggle_complete(task_id):
    task = Task.query.get_or_404(task_id)

    if task.user_id != current_user.id:
        return jsonify({"success": False, "message": "Yetkisiz işlem"}), 403

    task.completed = not task.completed
    db.session.commit()
    message = f"Görev '{task.title}' {'tamamlandı. 🎉' if task.completed else 'yeniden etkinleştirildi. ↩️'}"
    
    # Rozet kontrolü
    new_badges = check_and_award_badges(current_user)

    # YENİ: Zamana bağlı rozetler için özel kontrol
    now_hour = datetime.now().hour
    now_weekday = datetime.now().weekday() # Pazartesi 0, Pazar 6
    user_badge_keys = {b.criteria_key for b in current_user.badges} # Güncel rozet anahtarlarını al

    # Gece Kuşu
    if task.completed and (now_hour >= 22 or now_hour < 2) and 'night_owl_1' not in user_badge_keys:
        badge = Badge.query.filter_by(criteria_key='night_owl_1').first() # Veritabanından rozeti çek
        if badge and badge not in current_user.badges: # Kullanıcıda yoksa ekle
            current_user.badges.append(badge)
            db.session.commit()
            new_badges.append(BADGE_CRITERIA['night_owl_1']) # Bildirim için ekle

    # Gece Bekçisi
    if task.completed and (now_hour >= 2 and now_hour <= 4) and 'night_watch_1' not in user_badge_keys:
        badge = Badge.query.filter_by(criteria_key='night_watch_1').first()
        if badge and badge not in current_user.badges:
            current_user.badges.append(badge)
            db.session.commit()
            new_badges.append(BADGE_CRITERIA['night_watch_1'])

    # Erken Kalkan
    if task.completed and now_hour < 8 and 'early_bird_1' not in user_badge_keys:
        badge = Badge.query.filter_by(criteria_key='early_bird_1').first()
        if badge and badge not in current_user.badges:
            current_user.badges.append(badge)
            db.session.commit()
            new_badges.append(BADGE_CRITERIA['early_bird_1'])

    # Hafta Sonu Savaşçısı (Cumartesi=5, Pazar=6)
    if task.completed and (now_weekday == 5 or now_weekday == 6) and 'weekend_warrior_1' not in user_badge_keys:
        badge = Badge.query.filter_by(criteria_key='weekend_warrior_1').first()
        if badge and badge not in current_user.badges:
            current_user.badges.append(badge)
            db.session.commit()
            new_badges.append(BADGE_CRITERIA['weekend_warrior_1'])

    # Dakik Şampiyon
    if task.completed and task.due_date and 'punctual_champion_1' not in user_badge_keys:
        time_diff = abs((datetime.now() - task.due_date).total_seconds())
        if time_diff <= 60: # 1 dakika tolerans
            badge = Badge.query.filter_by(criteria_key='punctual_champion_1').first()
            if badge and badge not in current_user.badges:
                current_user.badges.append(badge)
                db.session.commit()
                new_badges.append(BADGE_CRITERIA['punctual_champion_1'])

    return jsonify({"success": True, "completed": task.completed, "message": message, "new_badges": new_badges})


@dashboard_bp.route("/toggle_task_star/<int:task_id>", methods=["POST"])
@login_required
def toggle_task_star(task_id):
    task = Task.query.get_or_404(task_id)
    if task.user_id != current_user.id:
        return jsonify({"success": False, "message": "Yetkisiz işlem"}), 403
    task.starred = not task.starred
    db.session.commit()
    message = f"Görev '{task.title}' {'yıldızlandı. ⭐' if task.starred else 'yıldızlardan kaldırıldı. ☆'}"
    
    # Rozet kontrolü
    new_badges = check_and_award_badges(current_user)
    return jsonify({"success": True, "starred": task.starred, "message": message, "new_badges": new_badges})


@dashboard_bp.route("/upcoming_tasks")
@login_required
def upcoming_tasks():
    now = datetime.now()
    upcoming = Task.query.filter(
        Task.user_id == current_user.id,
        Task.due_date != None,
        Task.due_date <= now + timedelta(hours=24),
        Task.completed == False
    ).order_by(Task.due_date).all()
    
    tasks_list = [
        {
            "id": t.id,
            "title": t.title,
            "content": t.content,
            "due_date": t.due_date.strftime("%Y-%m-%dT%H:%M"),
            "starred": t.starred,
            "tags": [tag.name for tag in t.tags]
        }
        for t in upcoming
    ]
    return jsonify(tasks_list)

@dashboard_bp.route("/overdue_tasks")
@login_required
def overdue_tasks():
    """Sadece vadesi geçmiş ve tamamlanmamış görevleri döndürür."""
    now = datetime.now()
    overdue = Task.query.filter(
        Task.user_id == current_user.id,
        Task.due_date != None,
        Task.due_date < now,
        Task.completed == False
    ).order_by(Task.due_date).all()
    
    tasks_list = [
        {
            "id": t.id,
            "title": t.title,
            "content": t.content,
            "due_date": t.due_date.strftime("%Y-%m-%dT%H:%M") if t.due_date else "",
            "starred": t.starred,
            "completed": t.completed,
            "tags": [tag.name for tag in t.tags]
        }
        for t in overdue
    ]
    return jsonify(tasks_list)

# YENİ ROTA: Görev sıralamasını güncellemek için
@dashboard_bp.route("/update_task_order", methods=["POST"])
@login_required
def update_task_order():
    task_ids = request.json.get('task_ids')
    if not task_ids:
        return jsonify({"success": False, "message": "Görev ID'leri eksik."}), 400

    try:
        for index, task_id in enumerate(task_ids):
            task = Task.query.get(task_id)
            if task and task.user_id == current_user.id:
                task.order = index
        db.session.commit()
        return jsonify({"success": True, "message": "Görev sırası güncellendi."})
    except Exception as e:
        db.session.rollback()
        return jsonify({"success": False, "message": "Sıralama güncellenirken bir hata oluştu."}), 500

# --- AYARLAR (HTML PARTIAL ve AJAX) ---

@dashboard_bp.route('/settings', methods=['GET'])
@login_required
def settings_partial():
    return render_template('settings.html', user=current_user)

@dashboard_bp.route('/update_settings', methods=['POST'])
@login_required
def update_user_settings():
    username = request.form.get('username')
    email = request.form.get('email')

    if not username or not email:
        return jsonify({"success": False, "message": "Kullanıcı adı ve e-posta boş bırakılamaz."})

    existing_user_by_username = User.query.filter_by(username=username).filter(User.id != current_user.id).first()
    existing_user_by_email = User.query.filter_by(email=email).filter(User.id != current_user.id).first()

    if existing_user_by_username:
        return jsonify({"success": False, "message": f"Kullanıcı adı '{username}' zaten alınmış."})
    if existing_user_by_email:
        return jsonify({"success": False, "message": f"E-posta '{email}' zaten alınmış."})

    current_user.username = username
    current_user.email = email
    db.session.commit()

    return jsonify({"success": True, "message": "Kullanıcı bilgileri başarıyla güncellendi."})

@dashboard_bp.route('/change_password', methods=['POST'])
@login_required
def change_password():
    old_pw = request.form.get("current_password")
    new_pw = request.form.get("new_password")
    confirm_pw = request.form.get("confirm_password")

    if not current_user.check_password(old_pw):
        return jsonify({"success": False, "message": "Mevcut şifre yanlış."})

    if new_pw != confirm_pw:
        return jsonify({"success": False, "message": "Yeni şifreler eşleşmiyor."})

    current_user.set_password(new_pw)
    db.session.commit()
    
    return jsonify({"success": True, "message": "Şifre başarıyla değiştirildi. Lütfen yeniden giriş yapın.", "redirect_logout": True})

# YENİ ROTA: Rozetleri listelemek için
@dashboard_bp.route('/badges')
@login_required
def badges_page():
    # Tüm olası rozetleri ve kullanıcının sahip olduklarını al
    all_badges_info = BADGE_CRITERIA
    user_badge_keys = {badge.criteria_key for badge in current_user.badges}

    badges_data = []
    for key, info in all_badges_info.items():
        badges_data.append({**info, 'earned': key in user_badge_keys})

    # Rozetleri isme göre sırala
    return render_template('badges.html', badges=sorted(badges_data, key=lambda x: x['name']))

@dashboard_bp.route("/user_stats_html")
@login_required
def user_stats_html():
    user_id = current_user.id
    now = datetime.now()
    
    # 1. Not İstatistikleri
    total_notes = db.session.scalar(db.select(db.func.count(Note.id)).filter_by(user_id=user_id))
    starred_notes_count = db.session.scalar(db.select(db.func.count(Note.id)).filter_by(user_id=user_id, starred=True))

    # 2. Görev İstatistikleri
    total_tasks = db.session.scalar(db.select(db.func.count(Task.id)).filter_by(user_id=user_id))
    
    # Bekleyen görev sayısı KRİTİK BİLGİ
    pending_tasks = db.session.scalar(db.select(db.func.count(Task.id)).filter_by(user_id=user_id, completed=False))
    
    # Gecikmiş görev sayısı (YENİ)
    overdue_tasks = db.session.scalar(
        db.select(db.func.count(Task.id)).filter(
            Task.user_id == user_id,
            Task.completed == False,
            Task.due_date != None,
            Task.due_date < now
        )
    )

    completed_tasks = db.session.scalar(db.select(db.func.count(Task.id)).filter_by(user_id=user_id, completed=True))
    starred_tasks_count = db.session.scalar(db.select(db.func.count(Task.id)).filter_by(user_id=user_id, starred=True))

    # 3. Toplam Yıldızlı Öğeler
    starred_count = starred_notes_count + starred_tasks_count

    return render_template('partials/_user_stats.html',
        total_notes=total_notes,
        pending_tasks=pending_tasks,
        overdue_tasks=overdue_tasks,
        completed_tasks=completed_tasks,
        starred_count=starred_count
    )

# YENİ ROTA: Kullanıcının tüm etiketlerini getirir
@dashboard_bp.route("/get_tags")
@login_required
def get_tags():
    """Kullanıcıya ait, en az bir not veya görevle ilişkilendirilmiş etiketleri getirir."""
    tags = db.session.query(Tag).filter(Tag.user_id == current_user.id)\
        .join(Tag.notes, isouter=True)\
        .join(Tag.tasks, isouter=True)\
        .filter(db.or_(Note.id.isnot(None), Task.id.isnot(None)))\
        .distinct().order_by(Tag.name).all()

    tags_list = [{"id": tag.id, "name": tag.name} for tag in tags]
    return jsonify(tags_list)

# YENİ ROTA: Belirli bir etikete ait notları ve görevleri getirir
@dashboard_bp.route("/get_items_by_tag/<int:tag_id>")
@login_required
def get_items_by_tag(tag_id):
    tag = Tag.query.filter_by(id=tag_id, user_id=current_user.id).first_or_404()

    # HATA DÜZELTME: with_parent() yanlış kullanılmıştı.
    # Doğru yöntem, .contains() ile ilişki üzerinden filtrelemektir.
    notes = Note.query.filter(Note.user_id == current_user.id, Note.tags.contains(tag)).order_by(Note.last_updated.desc()).all()
    tasks = Task.query.filter(Task.user_id == current_user.id, Task.tags.contains(tag)).order_by(Task.completed, Task.order, Task.id.desc()).all()



    notes_list = [{
        "id": n.id, "title": n.title, "content": n.content, "starred": n.starred,
        "last_updated": n.last_updated.strftime('%Y-%m-%d %H:%M'),
        "tags": [t.name for t in n.tags]
    } for n in notes]

    tasks_list = [{
        "id": t.id, "title": t.title, "content": t.content, "completed": t.completed,
        "due_date": t.due_date.strftime("%Y-%m-%dT%H:%M") if t.due_date else "",
        "starred": t.starred, "tags": [tag.name for tag in t.tags]
    } for t in tasks]

    return jsonify({"tag_name": tag.name, "notes": notes_list, "tasks": tasks_list})
